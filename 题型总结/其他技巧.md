#### 23.合并K个排序链表

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

###### 题解

```c++
/***
 思路：每次多取一个链表合并，合并n-1次。
 ***/
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size()==0) return nullptr;
        if(lists.size()==1) return lists[0];
        ListNode *p=lists[0], *q;
        for(int i=1;i<lists.size();i++){
            q=lists[i];
            p=merge(p,q);
        }
        return p;
    }
    ListNode* merge(ListNode *p1, ListNode *p2){
        ListNode *p=new ListNode(0);
        ListNode *head=p;
        head=p;
        if(p2==NULL) return p1;
        if(p1==NULL) return p2;
        while(p1&&p2){
            if(p1->val<p2->val){
                p->next=p1;
                p1=p1->next;
            }
            else{
                p->next=p2;
                p2=p2->next;
            }
            p=p->next;
        }
        if(p1)
            p->next=p1;
        if(p2)
            p->next=p2;
        return head->next;
    }
};
/***
其他方法：
1.分治，第一次为2,2,2,... 第二次为4,4,4...
2.优先队列
***/
```


#### 49.字母异位词分组

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

###### 题解

```c++
/***
注意点：
1.auto x:range   auto拷贝一份range元素，但不会改变range的值
2.const auto& x:range    只读取range中元素，不会拷贝进行拷贝也不会修改range的值
***/
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        map<string, vector<string>> map;
        vector<vector<string>> res;
        for(auto str:strs){//auto会拷贝一份，不会改变strs
            string tmp = str;
            sort(tmp.begin(), tmp.end());
            map[tmp].push_back(str);
        }
        for(const auto& m:map)//const auto& 只读取其中元素的值，不进行拷贝也不修改map
            res.push_back(m.second);
        return res;
    }
};
```
